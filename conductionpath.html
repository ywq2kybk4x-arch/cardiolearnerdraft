<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Conduction Path Animation</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>

<!-- Importmap so we can use ES modules from a CDN -->
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

let renderer, scene, camera, controls;
let conductionCurve = null;
let pulseMesh = null;

// One heartbeat duration (seconds) – slower overall
const BEAT_DURATION = 2.5;
const CONDUCTION_FRACTION = 0.45; // part of beat where conduction occurs

// temp vector for smoothing
const targetPos = new THREE.Vector3();

init();
loadModel();
animate();

function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);

  camera = new THREE.PerspectiveCamera(
    45,
    window.innerWidth / window.innerHeight,
    0.1,
    100
  );
  camera.position.set(2.5, 1.8, 2.5);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  const hemi = new THREE.HemisphereLight(0xffffff, 0x222222, 1.1);
  scene.add(hemi);

  const dir = new THREE.DirectionalLight(0xffffff, 1.0);
  dir.position.set(5, 10, 5);
  scene.add(dir);

  window.addEventListener('resize', onWindowResize);
}

function loadModel() {
  const loader = new GLTFLoader();

  loader.load(
    'assets/conductionpathmesh.glb',
    (gltf) => {
      const root = gltf.scene;
      scene.add(root);

      // Center the whole heart
      const box = new THREE.Box3().setFromObject(root);
      const center = box.getCenter(new THREE.Vector3());
      root.position.sub(center);

      console.log('✅ GLB loaded');

      // Try to find the "ConductionPath" node first
      const pathRoot = root.getObjectByName('ConductionPath') || root;

      // ---- Find a usable conduction MESH under that node ----
      let pathMesh = null;

      pathRoot.traverse((o) => {
        if (
          !pathMesh &&
          o.isMesh &&
          o.geometry &&
          o.geometry.attributes &&
          o.geometry.attributes.position
        ) {
          pathMesh = o;
        }
      });

      if (!pathMesh) {
        console.error('❌ No conduction mesh with position attribute found');
        console.log('Available object names:');
        root.traverse((o) => console.log(' -', o.name, o.type));
        return;
      }

      console.log('✅ Using conduction mesh:', pathMesh.name, pathMesh.type);

      // ---- Build spline from mesh vertices (in world space) ----
      const posAttr = pathMesh.geometry.attributes.position;
      const pts = [];
      const v = new THREE.Vector3();

      pathMesh.updateWorldMatrix(true, false);

      for (let i = 0; i < posAttr.count; i++) {
        v.fromBufferAttribute(posAttr, i);
        pathMesh.localToWorld(v);
        pts.push(v.clone());
      }

      console.log('✅ Spline point count:', pts.length);
      if (pts.length < 2) {
        console.error('❌ Not enough points to build a curve.');
        return;
      }

      conductionCurve = new THREE.CatmullRomCurve3(pts, false, 'centripetal');

      // ---- Electrical pulse sphere ----
      const pulseGeo = new THREE.SphereGeometry(0.06, 24, 24);
      const pulseMat = new THREE.MeshPhongMaterial({
        color: 0xfff566,
        emissive: 0xfff566,
        emissiveIntensity: 3.0
      });

      pulseMesh = new THREE.Mesh(pulseGeo, pulseMat);
      pulseMesh.visible = false; // start hidden
      scene.add(pulseMesh);

      console.log('✅ Pulse mesh created');
    },
    undefined,
    (err) => {
      console.error('GLB load error:', err);
    }
  );
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
  requestAnimationFrame(animate);

  const now = performance.now() / 1000;
  const phase = (now % BEAT_DURATION) / BEAT_DURATION; // 0 → 1 each beat

  if (conductionCurve && pulseMesh) {
    if (phase < CONDUCTION_FRACTION) {
      // Conduction is happening during the first chunk of the beat
      const beatPhase = phase / CONDUCTION_FRACTION; // 0–1 within conduction window

      // Map beatPhase → path position t
      // First 25% of conduction window: first 10% of path (atria + AV delay)
      // Remaining 75%: last 90% of path (His–Purkinje fast)
      let t;
      if (beatPhase < 0.25) {
        t = beatPhase * (0.10 / 0.25); // 0 → 0.10
      } else {
        t = 0.10 + (beatPhase - 0.25) * (0.90 / 0.75); // 0.10 → 1.0
      }

      // Flip direction if needed:
      // t = 1.0 - t;

      conductionCurve.getPointAt(t, targetPos);

      // Smooth motion: ease toward target point
      if (!pulseMesh.visible) {
        // first frame of the beat – snap to starting position
        pulseMesh.position.copy(targetPos);
      } else {
        // interpolate for smooth glide
        pulseMesh.position.lerp(targetPos, 0.01); // smaller factor = smoother/slower
      }

      pulseMesh.visible = true;
    } else {
      // Diastole / rest: hide the pulse
      pulseMesh.visible = false;
    }
  }

  controls.update();
  renderer.render(scene, camera);
}
</script>

</body>
</html><!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Conduction Path Animation</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>

<!-- Importmap so we can use ES modules from a CDN -->
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

let renderer, scene, camera, controls;
let conductionCurve = null;
let pulseMesh = null;

// One heartbeat duration (seconds) – slower overall
const BEAT_DURATION = 50;
const CONDUCTION_FRACTION = 20; // part of beat where conduction occurs

// temp vector for smoothing
const targetPos = new THREE.Vector3();

init();
loadModel();
animate();

function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);

  camera = new THREE.PerspectiveCamera(
    45,
    window.innerWidth / window.innerHeight,
    0.1,
    100
  );
  camera.position.set(2.5, 1.8, 2.5);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  const hemi = new THREE.HemisphereLight(0xffffff, 0x222222, 1.1);
  scene.add(hemi);

  const dir = new THREE.DirectionalLight(0xffffff, 1.0);
  dir.position.set(5, 10, 5);
  scene.add(dir);

  window.addEventListener('resize', onWindowResize);
}

function loadModel() {
  const loader = new GLTFLoader();

  loader.load(
    'assets/conductionpathmesh.glb',
    (gltf) => {
      const root = gltf.scene;
      scene.add(root);

      // Center the whole heart
      const box = new THREE.Box3().setFromObject(root);
      const center = box.getCenter(new THREE.Vector3());
      root.position.sub(center);

      console.log('✅ GLB loaded');

      // Try to find the "ConductionPath" node first
      const pathRoot = root.getObjectByName('ConductionPath') || root;

      // ---- Find a usable conduction MESH under that node ----
      let pathMesh = null;

      pathRoot.traverse((o) => {
        if (
          !pathMesh &&
          o.isMesh &&
          o.geometry &&
          o.geometry.attributes &&
          o.geometry.attributes.position
        ) {
          pathMesh = o;
        }
      });

      if (!pathMesh) {
        console.error('❌ No conduction mesh with position attribute found');
        console.log('Available object names:');
        root.traverse((o) => console.log(' -', o.name, o.type));
        return;
      }

      console.log('✅ Using conduction mesh:', pathMesh.name, pathMesh.type);

      // ---- Build spline from mesh vertices (in world space) ----
      const posAttr = pathMesh.geometry.attributes.position;
      const pts = [];
      const v = new THREE.Vector3();

      pathMesh.updateWorldMatrix(true, false);

      for (let i = 0; i < posAttr.count; i++) {
        v.fromBufferAttribute(posAttr, i);
        pathMesh.localToWorld(v);
        pts.push(v.clone());
      }

      console.log('✅ Spline point count:', pts.length);
      if (pts.length < 2) {
        console.error('❌ Not enough points to build a curve.');
        return;
      }

      conductionCurve = new THREE.CatmullRomCurve3(pts, false, 'centripetal');

      // ---- Electrical pulse sphere ----
      const pulseGeo = new THREE.SphereGeometry(0.06, 24, 24);
      const pulseMat = new THREE.MeshPhongMaterial({
        color: 0xfff566,
        emissive: 0xfff566,
        emissiveIntensity: 3.0
      });

      pulseMesh = new THREE.Mesh(pulseGeo, pulseMat);
      pulseMesh.visible = false; // start hidden
      scene.add(pulseMesh);

      console.log('✅ Pulse mesh created');
    },
    undefined,
    (err) => {
      console.error('GLB load error:', err);
    }
  );
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
  requestAnimationFrame(animate);

  const now = performance.now() / 1000;
  const phase = (now % BEAT_DURATION) / BEAT_DURATION; // 0 → 1 each beat

  if (conductionCurve && pulseMesh) {
    if (phase < CONDUCTION_FRACTION) {
      // Conduction is happening during the first chunk of the beat
      const beatPhase = phase / CONDUCTION_FRACTION; // 0–1 within conduction window

      // Map beatPhase → path position t
      // First 25% of conduction window: first 10% of path (atria + AV delay)
      // Remaining 75%: last 90% of path (His–Purkinje fast)
      let t;
      if (beatPhase < 0.25) {
        t = beatPhase * (0.10 / 0.25); // 0 → 0.10
      } else {
        t = 0.10 + (beatPhase - 0.25) * (0.90 / 0.75); // 0.10 → 1.0
      }

      // Flip direction if needed:
      // t = 1.0 - t;

      conductionCurve.getPointAt(t, targetPos);

      // Smooth motion: ease toward target point
      if (!pulseMesh.visible) {
        // first frame of the beat – snap to starting position
        pulseMesh.position.copy(targetPos);
      } else {
        // interpolate for smooth glide
        pulseMesh.position.lerp(targetPos, 0.15); // smaller factor = smoother/slower
      }

      pulseMesh.visible = true;
    } else {
      // Diastole / rest: hide the pulse
      pulseMesh.visible = false;
    }
  }

  controls.update();
  renderer.render(scene, camera);
}
</script>
<script src="./assets/ai-tutor-tab.js"></script>
<script>
  if (!window.__aiTutorTabInitialized) {
    console.warn('[AI Tutor] ai-tutor-tab.js did not initialize. Check script path and console errors.');
  }
</script>

</body>
</html>
